from machine import Pin, ADCfrom micropython import constimport utimefrom math import exp, logclass BaseMQ(object):    ## Measuring attempts in cycle    MQ_SAMPLE_TIMES = const(5)    ## Delay after each measurement, in ms    MQ_SAMPLE_INTERVAL = const(5000)    ## Heating period, in ms    MQ_HEATING_PERIOD = const(60000)    ## Cooling period, in ms    MQ_COOLING_PERIOD = const(90000)    ## This strategy measure values immideatly, so it might be inaccurate. Should be    #  suitable for tracking dynamics, rather than actual values    STRATEGY_FAST = const(1)    ## This strategy measure values separately. For a single measurement    #    MQ_SAMPLE_TIMES measurements are taken in interval MQ_SAMPLE_INTERVAL.    #    I.e. for multi-data sensors, like MQ2 it would take a while to receive full data    STRATEGY_ACCURATE = const(2)        def __init__(self, pinData, baseVoltage=5.0, pinHeater=-1, boardResistance=10, measuringStrategy=STRATEGY_ACCURATE):        ## Heater is enabled        self._heater = False        ## Heater is enabled        self._cooler = False        ## Base resistance of module                 self._ro = -1               self._useSeparateHeater = False        self._baseVoltage = baseVoltage        ## @var _lastMeasurement - when last measurement was taken        self._lastMeasurement = utime.ticks_ms()        self._rsCache = None        self.dataIsReliable = False        self.pinData = ADC(Pin(pinData))  # Ensure pinData is converted to an int for Pin        self.measuringStrategy = measuringStrategy        self._boardResistance = boardResistance        if pinHeater != -1:            self._useSeparateHeater = True            self._pinHeater = Pin(pinHeater, Pin.OUT)        def getRoInCleanAir(self):        raise NotImplementedError("Please Implement this method")    def calibrate(self, ro=-1):        if ro == -1:            ro = 0            print("Calibrating:")            for i in range(0, self.MQ_SAMPLE_TIMES):                print("Step {0}".format(i))                ro += self.__calculateResistance__(self.pinData.read())                utime.sleep_ms(self.MQ_SAMPLE_INTERVAL)            ro = ro / (self.getRoInCleanAir() * self.MQ_SAMPLE_TIMES)        self._ro = ro        self._stateCalibrate = True    def heaterPwrHigh(self):        if self._useSeparateHeater:            self._pinHeater.on()        self._heater = True        self._prMillis = utime.ticks_ms()    def heaterPwrLow(self):        if self._useSeparateHeater:            self._pinHeater.duty(75)        self._heater = True        self._cooler = True        self._prMillis = utime.ticks_ms()    def heaterPwrOff(self):        if self._useSeparateHeater:            self._pinHeater.off()        self._heater = False    def __calculateResistance__(self, rawAdc):        vrl = rawAdc * (self._baseVoltage / 1023)        rsAir = (self._baseVoltage - vrl) / vrl * self._boardResistance        return rsAir    def __readRs__(self):        if self.measuringStrategy == self.STRATEGY_ACCURATE:            rs = 0            for i in range(0, self.MQ_SAMPLE_TIMES):                rs += self.__calculateResistance__(self.pinData.read())                utime.sleep_ms(self.MQ_SAMPLE_INTERVAL)            rs = rs / self.MQ_SAMPLE_TIMES            self._rsCache = rs            self.dataIsReliable = True            self._lastMeasurement = utime.ticks_ms()        else:            rs = self.__calculateResistance__(self.pinData.read())            self.dataIsReliable = False        return rs    def readScaled(self, a, b):                return exp((log(self.readRatio()) - b) / a)    def readRatio(self):        return self.__readRs__() / self._ro    def heatingCompleted(self):        if (self._heater) and (not self._cooler) and (utime.ticks_diff(utime.ticks_ms(), self._prMillis) > self.MQ_HEATING_PERIOD):            return True        else:            return False    def coolanceCompleted(self):        if (self._heater) and (self._cooler) and (utime.ticks_diff(utime.ticks_ms(), self._prMillis) > self.MQ_COOLING_PERIOD):            return True        else:            return False    def cycleHeat(self):        self._heater = False        self._cooler = False        self.heaterPwrHigh()        print("Heated sensor")    def atHeatCycleEnd(self):        if self.heatingCompleted():            self.heaterPwrLow()            print("Cool sensor")            return False        elif self.coolanceCompleted():            self.heaterPwrOff()            return True        else:            return False